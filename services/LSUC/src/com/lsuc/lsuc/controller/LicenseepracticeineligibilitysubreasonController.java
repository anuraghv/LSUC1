/*Copyright (c) 2015-2016 wavemaker-com All Rights Reserved.
 This software is the confidential and proprietary information of wavemaker-com You shall not disclose such Confidential Information and shall use it only in accordance
 with the terms of the source code license agreement you entered into with wavemaker-com*/
package com.lsuc.lsuc.controller;

/*This is a Studio Managed File. DO NOT EDIT THIS FILE. Your changes may be reverted by Studio.*/


import java.sql.Date;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.wavemaker.runtime.data.exception.EntityNotFoundException;
import com.wavemaker.runtime.data.export.ExportType;
import com.wavemaker.runtime.data.expression.QueryFilter;
import com.wavemaker.runtime.data.model.AggregationInfo;
import com.wavemaker.runtime.file.model.Downloadable;
import com.wavemaker.tools.api.core.annotations.WMAccessVisibility;
import com.wavemaker.tools.api.core.models.AccessSpecifier;
import com.wordnik.swagger.annotations.Api;
import com.wordnik.swagger.annotations.ApiOperation;
import com.wordnik.swagger.annotations.ApiParam;

import com.lsuc.lsuc.Licenseepracticeineligibilitysubreason;
import com.lsuc.lsuc.service.LicenseepracticeineligibilitysubreasonService;


/**
 * Controller object for domain model class Licenseepracticeineligibilitysubreason.
 * @see Licenseepracticeineligibilitysubreason
 */
@RestController("LSUC.LicenseepracticeineligibilitysubreasonController")
@Api(value = "LicenseepracticeineligibilitysubreasonController", description = "Exposes APIs to work with Licenseepracticeineligibilitysubreason resource.")
@RequestMapping("/LSUC/Licenseepracticeineligibilitysubreason")
public class LicenseepracticeineligibilitysubreasonController {

    private static final Logger LOGGER = LoggerFactory.getLogger(LicenseepracticeineligibilitysubreasonController.class);

    @Autowired
	@Qualifier("LSUC.LicenseepracticeineligibilitysubreasonService")
	private LicenseepracticeineligibilitysubreasonService licenseepracticeineligibilitysubreasonService;

	@ApiOperation(value = "Creates a new Licenseepracticeineligibilitysubreason instance.")
	@RequestMapping(method = RequestMethod.POST)
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
	public Licenseepracticeineligibilitysubreason createLicenseepracticeineligibilitysubreason(@RequestBody Licenseepracticeineligibilitysubreason licenseepracticeineligibilitysubreason) {
		LOGGER.debug("Create Licenseepracticeineligibilitysubreason with information: {}" , licenseepracticeineligibilitysubreason);

		licenseepracticeineligibilitysubreason = licenseepracticeineligibilitysubreasonService.create(licenseepracticeineligibilitysubreason);
		LOGGER.debug("Created Licenseepracticeineligibilitysubreason with information: {}" , licenseepracticeineligibilitysubreason);

	    return licenseepracticeineligibilitysubreason;
	}


    @ApiOperation(value = "Returns the Licenseepracticeineligibilitysubreason instance associated with the given id.")
    @RequestMapping(value = "/{id:.+}", method = RequestMethod.GET)
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public Licenseepracticeineligibilitysubreason getLicenseepracticeineligibilitysubreason(@PathVariable("id") Integer id) throws EntityNotFoundException {
        LOGGER.debug("Getting Licenseepracticeineligibilitysubreason with id: {}" , id);

        Licenseepracticeineligibilitysubreason foundLicenseepracticeineligibilitysubreason = licenseepracticeineligibilitysubreasonService.getById(id);
        LOGGER.debug("Licenseepracticeineligibilitysubreason details with id: {}" , foundLicenseepracticeineligibilitysubreason);

        return foundLicenseepracticeineligibilitysubreason;
    }

    @ApiOperation(value = "Updates the Licenseepracticeineligibilitysubreason instance associated with the given id.")
    @RequestMapping(value = "/{id:.+}", method = RequestMethod.PUT)
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public Licenseepracticeineligibilitysubreason editLicenseepracticeineligibilitysubreason(@PathVariable("id") Integer id, @RequestBody Licenseepracticeineligibilitysubreason licenseepracticeineligibilitysubreason) throws EntityNotFoundException {
        LOGGER.debug("Editing Licenseepracticeineligibilitysubreason with id: {}" , licenseepracticeineligibilitysubreason.getPk());

        licenseepracticeineligibilitysubreason.setPk(id);
        licenseepracticeineligibilitysubreason = licenseepracticeineligibilitysubreasonService.update(licenseepracticeineligibilitysubreason);
        LOGGER.debug("Licenseepracticeineligibilitysubreason details with id: {}" , licenseepracticeineligibilitysubreason);

        return licenseepracticeineligibilitysubreason;
    }

    @ApiOperation(value = "Deletes the Licenseepracticeineligibilitysubreason instance associated with the given id.")
    @RequestMapping(value = "/{id:.+}", method = RequestMethod.DELETE)
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public boolean deleteLicenseepracticeineligibilitysubreason(@PathVariable("id") Integer id) throws EntityNotFoundException {
        LOGGER.debug("Deleting Licenseepracticeineligibilitysubreason with id: {}" , id);

        Licenseepracticeineligibilitysubreason deletedLicenseepracticeineligibilitysubreason = licenseepracticeineligibilitysubreasonService.delete(id);

        return deletedLicenseepracticeineligibilitysubreason != null;
    }

    @RequestMapping(value = "/effectiveFromDate-effectiveToDate-licenseePracticeIneligibilityReasonFk-practiceIneligibilitySubReasonFk", method = RequestMethod.GET)
    @ApiOperation(value = "Returns the matching Licenseepracticeineligibilitysubreason with given unique key values.")
    public Licenseepracticeineligibilitysubreason getByEffectiveFromDateAndEffectiveToDateAndLicenseePracticeIneligibilityReasonFkAndPracticeIneligibilitySubReasonFk(@RequestParam("effectiveFromDate") Date effectiveFromDate, @RequestParam("effectiveToDate") Date effectiveToDate, @RequestParam("licenseePracticeIneligibilityReasonFk") Integer licenseePracticeIneligibilityReasonFk, @RequestParam("practiceIneligibilitySubReasonFk") Integer practiceIneligibilitySubReasonFk) {
        LOGGER.debug("Getting Licenseepracticeineligibilitysubreason with uniques key EffectiveFromDateAndEffectiveToDateAndLicenseePracticeIneligibilityReasonFkAndPracticeIneligibilitySubReasonFk");
        return licenseepracticeineligibilitysubreasonService.getByEffectiveFromDateAndEffectiveToDateAndLicenseePracticeIneligibilityReasonFkAndPracticeIneligibilitySubReasonFk(effectiveFromDate, effectiveToDate, licenseePracticeIneligibilityReasonFk, practiceIneligibilitySubReasonFk);
    }

    /**
     * @deprecated Use {@link #findLicenseepracticeineligibilitysubreasons(String, Pageable)} instead.
     */
    @Deprecated
    @ApiOperation(value = "Returns the list of Licenseepracticeineligibilitysubreason instances matching the search criteria.")
    @RequestMapping(value = "/search", method = RequestMethod.POST)
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public Page<Licenseepracticeineligibilitysubreason> searchLicenseepracticeineligibilitysubreasonsByQueryFilters( Pageable pageable, @RequestBody QueryFilter[] queryFilters) {
        LOGGER.debug("Rendering Licenseepracticeineligibilitysubreasons list");
        return licenseepracticeineligibilitysubreasonService.findAll(queryFilters, pageable);
    }

    @ApiOperation(value = "Returns the paginated list of Licenseepracticeineligibilitysubreason instances matching the optional query (q) request param. If there is no query provided, it returns all the instances. Pagination & Sorting parameters such as page& size, sort can be sent as request parameters. The sort value should be a comma separated list of field names & optional sort order to sort the data on. eg: field1 asc, field2 desc etc ")
    @RequestMapping(method = RequestMethod.GET)
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public Page<Licenseepracticeineligibilitysubreason> findLicenseepracticeineligibilitysubreasons(@ApiParam("conditions to filter the results") @RequestParam(value = "q", required = false) String query, Pageable pageable) {
        LOGGER.debug("Rendering Licenseepracticeineligibilitysubreasons list");
        return licenseepracticeineligibilitysubreasonService.findAll(query, pageable);
    }

    @ApiOperation(value = "Returns the paginated list of Licenseepracticeineligibilitysubreason instances matching the optional query (q) request param. This API should be used only if the query string is too big to fit in GET request with request param. The request has to made in application/x-www-form-urlencoded format.")
    @RequestMapping(value="/filter", method = RequestMethod.POST, consumes= "application/x-www-form-urlencoded")
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public Page<Licenseepracticeineligibilitysubreason> filterLicenseepracticeineligibilitysubreasons(@ApiParam("conditions to filter the results") @RequestParam(value = "q", required = false) String query, Pageable pageable) {
        LOGGER.debug("Rendering Licenseepracticeineligibilitysubreasons list");
        return licenseepracticeineligibilitysubreasonService.findAll(query, pageable);
    }

    @ApiOperation(value = "Returns downloadable file for the data matching the optional query (q) request param. If query string is too big to fit in GET request's query param, use POST method with application/x-www-form-urlencoded format.")
    @RequestMapping(value = "/export/{exportType}", method = {RequestMethod.GET,  RequestMethod.POST}, produces = "application/octet-stream")
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    public Downloadable exportLicenseepracticeineligibilitysubreasons(@PathVariable("exportType") ExportType exportType, @ApiParam("conditions to filter the results") @RequestParam(value = "q", required = false) String query, Pageable pageable) {
         return licenseepracticeineligibilitysubreasonService.export(exportType, query, pageable);
    }

	@ApiOperation(value = "Returns the total count of Licenseepracticeineligibilitysubreason instances matching the optional query (q) request param. If query string is too big to fit in GET request's query param, use POST method with application/x-www-form-urlencoded format.")
	@RequestMapping(value = "/count", method = {RequestMethod.GET, RequestMethod.POST})
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
	public Long countLicenseepracticeineligibilitysubreasons( @ApiParam("conditions to filter the results") @RequestParam(value = "q", required = false) String query) {
		LOGGER.debug("counting Licenseepracticeineligibilitysubreasons");
		return licenseepracticeineligibilitysubreasonService.count(query);
	}

    @ApiOperation(value = "Returns aggregated result with given aggregation info")
	@RequestMapping(value = "/aggregations", method = RequestMethod.POST)
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
	public Page<Map<String, Object>> getLicenseepracticeineligibilitysubreasonAggregatedValues(@RequestBody AggregationInfo aggregationInfo, Pageable pageable) {
        LOGGER.debug("Fetching aggregated results for {}", aggregationInfo);
        return licenseepracticeineligibilitysubreasonService.getAggregatedValues(aggregationInfo, pageable);
    }


    /**
	 * This setter method should only be used by unit tests
	 *
	 * @param service LicenseepracticeineligibilitysubreasonService instance
	 */
	protected void setLicenseepracticeineligibilitysubreasonService(LicenseepracticeineligibilitysubreasonService service) {
		this.licenseepracticeineligibilitysubreasonService = service;
	}

}

